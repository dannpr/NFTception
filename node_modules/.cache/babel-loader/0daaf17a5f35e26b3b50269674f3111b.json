{"ast":null,"code":"/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n// @ts-ignore module with no types\nimport { transform } from 'streaming-iterables';\nimport pRetry from 'p-retry';\nimport { TreewalkCarSplitter } from 'carbites/treewalk';\nimport * as API from './lib/interface.js';\nimport * as Token from './token.js';\nimport { fetch, File, Blob, FormData } from './platform.js';\nimport { toGatewayURL } from './gateway.js';\nconst MAX_STORE_RETRIES = 5;\nconst MAX_CONCURRENT_UPLOADS = 3;\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 10; // chunk to ~10MB CARs\n\n/**\n * @implements API.Service\n */\n\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?:URL}} options\n   */\n  constructor({\n    token,\n    endpoint = new URL('https://api.nft.storage')\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token;\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n\n    this.endpoint = endpoint;\n  }\n  /**\n   * @hidden\n   * @param {string} token\n   */\n\n\n  static auth(token) {\n    if (!token) throw new Error('missing token');\n    return {\n      Authorization: `Bearer ${token}`\n    };\n  }\n  /**\n   * @param {API.Service} service\n   * @param {Blob} blob\n   * @returns {Promise<API.CIDString>}\n   */\n\n\n  static async storeBlob({\n    endpoint,\n    token\n  }, blob) {\n    const url = new URL('/upload', endpoint);\n\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content');\n    }\n\n    const request = await fetch(url.toString(), {\n      method: 'POST',\n      headers: NFTStorage.auth(token),\n      body: blob\n    });\n    const result = await request.json();\n\n    if (result.ok) {\n      return result.value.cid;\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n  /**\n   * @param {API.Service} service\n   * @param {Blob|API.CarReader} car\n   * @param {{onStoredChunk?: (size: number) => void}} [options]\n   * @returns {Promise<API.CIDString>}\n   */\n\n\n  static async storeCar({\n    endpoint,\n    token\n  }, car, {\n    onStoredChunk\n  } = {}) {\n    const targetSize = MAX_CHUNK_SIZE;\n    const splitter = car instanceof Blob ? await TreewalkCarSplitter.fromBlob(car, targetSize) : new TreewalkCarSplitter(car, targetSize);\n    const upload = transform(MAX_CONCURRENT_UPLOADS, async (\n    /** @type {AsyncIterable<Uint8Array>} */\n    car) => {\n      const carParts = [];\n\n      for await (const part of car) {\n        carParts.push(part);\n      }\n\n      const carFile = new Blob(carParts, {\n        type: 'application/car'\n      });\n      const res = await pRetry(() => NFTStorage.storeBlob({\n        endpoint,\n        token\n      }, carFile), {\n        retries: MAX_STORE_RETRIES\n      });\n      onStoredChunk && onStoredChunk(carFile.size);\n      return res;\n    });\n    let root;\n\n    for await (const cid of upload(splitter.cars())) {\n      root = cid;\n    } // @ts-ignore there will always be a root, or carbites will fail\n\n\n    return root;\n  }\n  /**\n   * @param {API.Service} service\n   * @param {Iterable<File>} files\n   * @returns {Promise<API.CIDString>}\n   */\n\n\n  static async storeDirectory({\n    endpoint,\n    token\n  }, files) {\n    const url = new URL('/upload', endpoint);\n    const body = new FormData();\n    let size = 0;\n\n    for (const file of files) {\n      body.append('file', file, file.name);\n      size += file.size;\n    }\n\n    if (size === 0) {\n      throw new Error('Total size of files should exceed 0, make sure to provide some content');\n    }\n\n    const response = await fetch(url.toString(), {\n      method: 'POST',\n      headers: NFTStorage.auth(token),\n      body\n    });\n    const result = await response.json();\n\n    if (result.ok) {\n      return result.value.cid;\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n  /**\n   * @template {API.TokenInput} T\n   * @param {API.Service} service\n   * @param {T} metadata\n   * @returns {Promise<API.Token<T>>}\n   */\n\n\n  static async store({\n    endpoint,\n    token\n  }, metadata) {\n    validateERC1155(metadata);\n    const url = new URL(`/store`, endpoint);\n    const body = Token.encode(metadata);\n    const paths = new Set(body.keys());\n    const response = await fetch(url.toString(), {\n      method: 'POST',\n      headers: NFTStorage.auth(token),\n      body\n    });\n    /** @type {API.StoreResponse<T>} */\n\n    const result = await response.json();\n\n    if (result.ok === true) {\n      const {\n        value\n      } = result;\n      return Token.decode(value, paths);\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n  /**\n   * @param {API.Service} service\n   * @param {string} cid\n   * @returns {Promise<API.StatusResult>}\n   */\n\n\n  static async status({\n    endpoint,\n    token\n  }, cid) {\n    const url = new URL(`/${cid}`, endpoint);\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token)\n    });\n    const result = await response.json();\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created)\n      };\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n  /**\n   * @param {API.PublicService} service\n   * @param {string} cid\n   * @returns {Promise<API.CheckResult>}\n   */\n\n\n  static async check({\n    endpoint\n  }, cid) {\n    const url = new URL(`/check/${cid}`, endpoint);\n    const response = await fetch(url.toString());\n    const result = await response.json();\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin\n      };\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n  /**\n   * @param {API.Service} service\n   * @param {string} cid\n   * @returns {Promise<void>}\n   */\n\n\n  static async delete({\n    endpoint,\n    token\n  }, cid) {\n    const url = new URL(`/${cid}`, endpoint);\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token)\n    });\n    const result = await response.json();\n\n    if (!result.ok) {\n      throw new Error(result.error.message);\n    }\n  } // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD'\n   * ```\n   *\n   * @param {Blob} blob\n   */\n\n\n  storeBlob(blob) {\n    return NFTStorage.storeBlob(this, blob);\n  }\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|API.CarReader} car\n   * @param {{onStoredChunk?: (size: number) => void}} [options]\n   */\n\n\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options);\n  }\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {Iterable<File>} files\n   */\n\n\n  storeDirectory(files) {\n    return NFTStorage.storeDirectory(this, files);\n  }\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')\n   * ```\n   *\n   * @param {string} cid\n   */\n\n\n  status(cid) {\n    return NFTStorage.status(this, cid);\n  }\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')\n   * ```\n   *\n   * @param {string} cid\n   */\n\n\n  delete(cid) {\n    return NFTStorage.delete(this, cid);\n  }\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')\n   * ```\n   *\n   * @param {string} cid\n   */\n\n\n  check(cid) {\n    return NFTStorage.check(this, cid);\n  }\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {API.TokenInput} T\n   * @param {T} token\n   * @returns {Promise<API.Token<T>>}\n   */\n\n\n  store(token) {\n    return NFTStorage.store(this, token);\n  }\n\n}\n/**\n * @param {API.TokenInput} metadata\n */\n\n\nconst validateERC1155 = ({\n  name,\n  description,\n  image,\n  decimals\n}) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError('string property `name` identifying the asset is required');\n  }\n\n  if (typeof description !== 'string') {\n    throw new TypeError('string property `description` describing asset is required');\n  }\n\n  if (!(image instanceof Blob) || !image.type.startsWith('image/')) {\n    throw new TypeError('proprety `image` must be a Blob or File object with `image/*` mime type');\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('proprety `decimals` must be an integer value');\n  }\n};\n/**\n * @param {API.Deal[]} deals\n * @returns {API.Deal[]}\n */\n\n\nconst decodeDeals = deals => deals.map(deal => {\n  const {\n    dealActivation,\n    dealExpiration,\n    lastChanged\n  } = {\n    dealExpiration: null,\n    dealActivation: null,\n    ...deal\n  };\n  return { ...deal,\n    lastChanged: new Date(lastChanged),\n    ...(dealActivation && {\n      dealActivation: new Date(dealActivation)\n    }),\n    ...(dealExpiration && {\n      dealExpiration: new Date(dealExpiration)\n    })\n  };\n});\n/**\n * @param {API.Pin} pin\n * @returns {API.Pin}\n */\n\n\nconst decodePin = pin => ({ ...pin,\n  created: new Date(pin.created)\n});\n\nconst TokenModel = Token.Token;\nexport { TokenModel as Token };\nexport { NFTStorage, File, Blob, FormData, toGatewayURL };\n/**\n * Just to verify API compatibility.\n * @type {API.API}\n */\n\nconst api = NFTStorage;\nvoid api;","map":{"version":3,"sources":["/Users/macdann/Desktop/ethccHack-NFT/Solar-NFT/node_modules/nft.storage/src/lib.js"],"names":["transform","pRetry","TreewalkCarSplitter","API","Token","fetch","File","Blob","FormData","toGatewayURL","MAX_STORE_RETRIES","MAX_CONCURRENT_UPLOADS","MAX_CHUNK_SIZE","NFTStorage","constructor","token","endpoint","URL","auth","Error","Authorization","storeBlob","blob","url","size","request","toString","method","headers","body","result","json","ok","value","cid","error","message","storeCar","car","onStoredChunk","targetSize","splitter","fromBlob","upload","carParts","part","push","carFile","type","res","retries","root","cars","storeDirectory","files","file","append","name","response","store","metadata","validateERC1155","encode","paths","Set","keys","decode","status","deals","decodeDeals","pin","decodePin","created","Date","check","delete","options","description","image","decimals","TypeError","startsWith","map","deal","dealActivation","dealExpiration","lastChanged","TokenModel","api"],"mappings":"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QAAQ,GAAG,MAAMrD,KAAK,CAACkB,GAAG,CAACG,QAAJ,EAAD,EAAiB;AAC3CC,MAAAA,MAAM,EAAE,QADmC;AAE3CC,MAAAA,OAAO,EAAEf,UAAU,CAACK,IAAX,CAAgBH,KAAhB;AAFkC,KAAjB,CAA5B;AAIA,UAAMe,MAAM,GAAG,MAAM4B,QAAQ,CAAC3B,IAAT,EAArB;;AACA,QAAI,CAACD,MAAM,CAACE,EAAZ,EAAgB;AACd,YAAM,IAAIb,KAAJ,CAAUW,MAAM,CAACK,KAAP,CAAaC,OAAvB,CAAN;AACD;AACF,GA3Oc,CA6Of;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEf,EAAAA,SAAS,CAACC,IAAD,EAAO;AACd,WAAOT,UAAU,CAACQ,SAAX,CAAqB,IAArB,EAA2BC,IAA3B,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEe,EAAAA,QAAQ,CAACC,GAAD,EAAMsC,OAAN,EAAe;AACrB,WAAO/D,UAAU,CAACwB,QAAX,CAAoB,IAApB,EAA0BC,GAA1B,EAA+BsC,OAA/B,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEvB,EAAAA,cAAc,CAACC,KAAD,EAAQ;AACpB,WAAOzC,UAAU,CAACwC,cAAX,CAA0B,IAA1B,EAAgCC,KAAhC,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEa,EAAAA,MAAM,CAACjC,GAAD,EAAM;AACV,WAAOrB,UAAU,CAACsD,MAAX,CAAkB,IAAlB,EAAwBjC,GAAxB,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","sourcesContent":["/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\n// @ts-ignore module with no types\nimport { transform } from 'streaming-iterables'\nimport pRetry from 'p-retry'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport * as API from './lib/interface.js'\nimport * as Token from './token.js'\nimport { fetch, File, Blob, FormData } from './platform.js'\nimport { toGatewayURL } from './gateway.js'\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 10 // chunk to ~10MB CARs\n\n/**\n * @implements API.Service\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?:URL}} options\n   */\n  constructor({ token, endpoint = new URL('https://api.nft.storage') }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n  }\n\n  /**\n   * @hidden\n   * @param {string} token\n   */\n  static auth(token) {\n    if (!token) throw new Error('missing token')\n    return { Authorization: `Bearer ${token}` }\n  }\n  /**\n   * @param {API.Service} service\n   * @param {Blob} blob\n   * @returns {Promise<API.CIDString>}\n   */\n  static async storeBlob({ endpoint, token }, blob) {\n    const url = new URL('/upload', endpoint)\n\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n\n    const request = await fetch(url.toString(), {\n      method: 'POST',\n      headers: NFTStorage.auth(token),\n      body: blob,\n    })\n    const result = await request.json()\n\n    if (result.ok) {\n      return result.value.cid\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n  /**\n   * @param {API.Service} service\n   * @param {Blob|API.CarReader} car\n   * @param {{onStoredChunk?: (size: number) => void}} [options]\n   * @returns {Promise<API.CIDString>}\n   */\n  static async storeCar({ endpoint, token }, car, { onStoredChunk } = {}) {\n    const targetSize = MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof Blob\n        ? await TreewalkCarSplitter.fromBlob(car, targetSize)\n        : new TreewalkCarSplitter(car, targetSize)\n\n    const upload = transform(\n      MAX_CONCURRENT_UPLOADS,\n      async (/** @type {AsyncIterable<Uint8Array>} */ car) => {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new Blob(carParts, {\n          type: 'application/car',\n        })\n        const res = await pRetry(\n          () => NFTStorage.storeBlob({ endpoint, token }, carFile),\n          { retries: MAX_STORE_RETRIES }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return res\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n    // @ts-ignore there will always be a root, or carbites will fail\n    return root\n  }\n  /**\n   * @param {API.Service} service\n   * @param {Iterable<File>} files\n   * @returns {Promise<API.CIDString>}\n   */\n  static async storeDirectory({ endpoint, token }, files) {\n    const url = new URL('/upload', endpoint)\n    const body = new FormData()\n    let size = 0\n    for (const file of files) {\n      body.append('file', file, file.name)\n      size += file.size\n    }\n\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n\n    const response = await fetch(url.toString(), {\n      method: 'POST',\n      headers: NFTStorage.auth(token),\n      body,\n    })\n    const result = await response.json()\n\n    if (result.ok) {\n      return result.value.cid\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * @template {API.TokenInput} T\n   * @param {API.Service} service\n   * @param {T} metadata\n   * @returns {Promise<API.Token<T>>}\n   */\n  static async store({ endpoint, token }, metadata) {\n    validateERC1155(metadata)\n\n    const url = new URL(`/store`, endpoint)\n    const body = Token.encode(metadata)\n    const paths = new Set(body.keys())\n\n    const response = await fetch(url.toString(), {\n      method: 'POST',\n      headers: NFTStorage.auth(token),\n      body,\n    })\n\n    /** @type {API.StoreResponse<T>} */\n    const result = await response.json()\n\n    if (result.ok === true) {\n      const { value } = result\n      return Token.decode(value, paths)\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n  /**\n   * @param {API.Service} service\n   * @param {string} cid\n   * @returns {Promise<API.StatusResult>}\n   */\n  static async status({ endpoint, token }, cid) {\n    const url = new URL(`/${cid}`, endpoint)\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n    })\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * @param {API.PublicService} service\n   * @param {string} cid\n   * @returns {Promise<API.CheckResult>}\n   */\n  static async check({ endpoint }, cid) {\n    const url = new URL(`/check/${cid}`, endpoint)\n    const response = await fetch(url.toString())\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * @param {API.Service} service\n   * @param {string} cid\n   * @returns {Promise<void>}\n   */\n  static async delete({ endpoint, token }, cid) {\n    const url = new URL(`/${cid}`, endpoint)\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n    })\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD'\n   * ```\n   *\n   * @param {Blob} blob\n   */\n  storeBlob(blob) {\n    return NFTStorage.storeBlob(this, blob)\n  }\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|API.CarReader} car\n   * @param {{onStoredChunk?: (size: number) => void}} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {Iterable<File>} files\n   */\n  storeDirectory(files) {\n    return NFTStorage.storeDirectory(this, files)\n  }\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')\n   * ```\n   *\n   * @param {string} cid\n   */\n  status(cid) {\n    return NFTStorage.status(this, cid)\n  }\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')\n   * ```\n   *\n   * @param {string} cid\n   */\n  delete(cid) {\n    return NFTStorage.delete(this, cid)\n  }\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD')\n   * ```\n   *\n   * @param {string} cid\n   */\n  check(cid) {\n    return NFTStorage.check(this, cid)\n  }\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {API.TokenInput} T\n   * @param {T} token\n   * @returns {Promise<API.Token<T>>}\n   */\n  store(token) {\n    return NFTStorage.store(this, token)\n  }\n}\n\n/**\n * @param {API.TokenInput} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof Blob) || !image.type.startsWith('image/')) {\n    throw new TypeError(\n      'proprety `image` must be a Blob or File object with `image/*` mime type'\n    )\n  }\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('proprety `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {API.Deal[]} deals\n * @returns {API.Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {API.Pin} pin\n * @returns {API.Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\nconst TokenModel = Token.Token\nexport { TokenModel as Token }\nexport { NFTStorage, File, Blob, FormData, toGatewayURL }\n\n/**\n * Just to verify API compatibility.\n * @type {API.API}\n */\nconst api = NFTStorage\nvoid api\n"]},"metadata":{},"sourceType":"module"}