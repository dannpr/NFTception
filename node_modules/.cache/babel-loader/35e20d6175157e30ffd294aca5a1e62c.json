{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar cid = require('multiformats/cid');\n\nvar encoder = require('./encoder.js');\n\nvar iteratorChannel = require('./iterator-channel.js');\n\nvar decoder = require('./decoder.js');\n\nclass CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n\n    const cid$1 = cid.CID.asCID(block.cid);\n\n    if (!cid$1) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid: cid$1,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n\n  static create(roots) {\n    roots = toRoots(roots);\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n\n  static createAppender() {\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n\n    encoder.setRoots = () => Promise.resolve();\n\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = decoder.bytesReader(bytes);\n    await decoder.readHeader(reader);\n    const newHeader = encoder.createHeader(roots);\n\n    if (reader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);\n    }\n\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n\n}\n\nclass CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n\n    this._iterating = true;\n    return this._iterator;\n  }\n\n}\n\nfunction encodeWriter() {\n  const iw = iteratorChannel.create();\n  const {\n    writer,\n    iterator\n  } = iw;\n  const encoder$1 = encoder.createEncoder(writer);\n  return {\n    encoder: encoder$1,\n    iterator\n  };\n}\n\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid$1 = cid.CID.asCID(roots);\n\n    if (!cid$1) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    return [cid$1];\n  }\n\n  const _roots = [];\n\n  for (const root of roots) {\n    const _root = cid.CID.asCID(root);\n\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    _roots.push(_root);\n  }\n\n  return _roots;\n}\n\nconst __browser = true;\nexports.CarWriter = CarWriter;\nexports.CarWriterOut = CarWriterOut;\nexports.__browser = __browser;","map":{"version":3,"sources":["/Users/macdann/Desktop/ethccHack-NFT/Solar-NFT/node_modules/@ipld/car/cjs/lib/writer-browser.js"],"names":["Object","defineProperty","exports","value","cid","require","encoder","iteratorChannel","decoder","CarWriter","constructor","roots","_encoder","_mutex","setRoots","_ended","put","block","bytes","Uint8Array","TypeError","Error","cid$1","CID","asCID","then","writeBlock","close","create","toRoots","iterator","encodeWriter","writer","out","CarWriterOut","createAppender","Promise","resolve","updateRootsInBytes","reader","bytesReader","readHeader","newHeader","createHeader","pos","length","set","_iterator","Symbol","asyncIterator","_iterating","iw","encoder$1","createEncoder","undefined","Array","isArray","_roots","root","_root","push","__browser"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,GAAG,GAAGC,OAAO,CAAC,kBAAD,CAAjB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,cAAD,CAArB;;AACA,IAAIE,eAAe,GAAGF,OAAO,CAAC,uBAAD,CAA7B;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,cAAD,CAArB;;AAEA,MAAMI,SAAN,CAAgB;AACdC,EAAAA,WAAW,CAACC,KAAD,EAAQL,OAAR,EAAiB;AAC1B,SAAKM,QAAL,GAAgBN,OAAhB;AACA,SAAKO,MAAL,GAAcP,OAAO,CAACQ,QAAR,CAAiBH,KAAjB,CAAd;AACA,SAAKI,MAAL,GAAc,KAAd;AACD;;AACQ,QAAHC,GAAG,CAACC,KAAD,EAAQ;AACf,QAAI,EAAEA,KAAK,CAACC,KAAN,YAAuBC,UAAzB,KAAwC,CAACF,KAAK,CAACb,GAAnD,EAAwD;AACtD,YAAM,IAAIgB,SAAJ,CAAc,qCAAd,CAAN;AACD;;AACD,QAAI,KAAKL,MAAT,EAAiB;AACf,YAAM,IAAIM,KAAJ,CAAU,gBAAV,CAAN;AACD;;AACD,UAAMC,KAAK,GAAGlB,GAAG,CAACmB,GAAJ,CAAQC,KAAR,CAAcP,KAAK,CAACb,GAApB,CAAd;;AACA,QAAI,CAACkB,KAAL,EAAY;AACV,YAAM,IAAIF,SAAJ,CAAc,qCAAd,CAAN;AACD;;AACD,SAAKP,MAAL,GAAc,KAAKA,MAAL,CAAYY,IAAZ,CAAiB,MAAM,KAAKb,QAAL,CAAcc,UAAd,CAAyB;AAC5DtB,MAAAA,GAAG,EAAEkB,KADuD;AAE5DJ,MAAAA,KAAK,EAAED,KAAK,CAACC;AAF+C,KAAzB,CAAvB,CAAd;AAIA,WAAO,KAAKL,MAAZ;AACD;;AACU,QAALc,KAAK,GAAG;AACZ,QAAI,KAAKZ,MAAT,EAAiB;AACf,YAAM,IAAIM,KAAJ,CAAU,gBAAV,CAAN;AACD;;AACD,UAAM,KAAKR,MAAX;AACA,SAAKE,MAAL,GAAc,IAAd;AACA,WAAO,KAAKH,QAAL,CAAce,KAAd,EAAP;AACD;;AACY,SAANC,MAAM,CAACjB,KAAD,EAAQ;AACnBA,IAAAA,KAAK,GAAGkB,OAAO,CAAClB,KAAD,CAAf;AACA,UAAM;AAACL,MAAAA,OAAD;AAAUwB,MAAAA;AAAV,QAAsBC,YAAY,EAAxC;AACA,UAAMC,MAAM,GAAG,IAAIvB,SAAJ,CAAcE,KAAd,EAAqBL,OAArB,CAAf;AACA,UAAM2B,GAAG,GAAG,IAAIC,YAAJ,CAAiBJ,QAAjB,CAAZ;AACA,WAAO;AACLE,MAAAA,MADK;AAELC,MAAAA;AAFK,KAAP;AAID;;AACoB,SAAdE,cAAc,GAAG;AACtB,UAAM;AAAC7B,MAAAA,OAAD;AAAUwB,MAAAA;AAAV,QAAsBC,YAAY,EAAxC;;AACAzB,IAAAA,OAAO,CAACQ,QAAR,GAAmB,MAAMsB,OAAO,CAACC,OAAR,EAAzB;;AACA,UAAML,MAAM,GAAG,IAAIvB,SAAJ,CAAc,EAAd,EAAkBH,OAAlB,CAAf;AACA,UAAM2B,GAAG,GAAG,IAAIC,YAAJ,CAAiBJ,QAAjB,CAAZ;AACA,WAAO;AACLE,MAAAA,MADK;AAELC,MAAAA;AAFK,KAAP;AAID;;AAC8B,eAAlBK,kBAAkB,CAACpB,KAAD,EAAQP,KAAR,EAAe;AAC5C,UAAM4B,MAAM,GAAG/B,OAAO,CAACgC,WAAR,CAAoBtB,KAApB,CAAf;AACA,UAAMV,OAAO,CAACiC,UAAR,CAAmBF,MAAnB,CAAN;AACA,UAAMG,SAAS,GAAGpC,OAAO,CAACqC,YAAR,CAAqBhC,KAArB,CAAlB;;AACA,QAAI4B,MAAM,CAACK,GAAP,KAAeF,SAAS,CAACG,MAA7B,EAAqC;AACnC,YAAM,IAAIxB,KAAJ,CAAW,+EAA+EkB,MAAM,CAACK,GAAK,yBAAyBF,SAAS,CAACG,MAAQ,SAAjJ,CAAN;AACD;;AACD3B,IAAAA,KAAK,CAAC4B,GAAN,CAAUJ,SAAV,EAAqB,CAArB;AACA,WAAOxB,KAAP;AACD;;AA5Da;;AA8DhB,MAAMgB,YAAN,CAAmB;AACjBxB,EAAAA,WAAW,CAACoB,QAAD,EAAW;AACpB,SAAKiB,SAAL,GAAiBjB,QAAjB;AACD;;AACoB,GAApBkB,MAAM,CAACC,aAAa,IAAI;AACvB,QAAI,KAAKC,UAAT,EAAqB;AACnB,YAAM,IAAI7B,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,SAAK6B,UAAL,GAAkB,IAAlB;AACA,WAAO,KAAKH,SAAZ;AACD;;AAVgB;;AAYnB,SAAShB,YAAT,GAAwB;AACtB,QAAMoB,EAAE,GAAG5C,eAAe,CAACqB,MAAhB,EAAX;AACA,QAAM;AAACI,IAAAA,MAAD;AAASF,IAAAA;AAAT,MAAqBqB,EAA3B;AACA,QAAMC,SAAS,GAAG9C,OAAO,CAAC+C,aAAR,CAAsBrB,MAAtB,CAAlB;AACA,SAAO;AACL1B,IAAAA,OAAO,EAAE8C,SADJ;AAELtB,IAAAA;AAFK,GAAP;AAID;;AACD,SAASD,OAAT,CAAiBlB,KAAjB,EAAwB;AACtB,MAAIA,KAAK,KAAK2C,SAAd,EAAyB;AACvB,WAAO,EAAP;AACD;;AACD,MAAI,CAACC,KAAK,CAACC,OAAN,CAAc7C,KAAd,CAAL,EAA2B;AACzB,UAAMW,KAAK,GAAGlB,GAAG,CAACmB,GAAJ,CAAQC,KAAR,CAAcb,KAAd,CAAd;;AACA,QAAI,CAACW,KAAL,EAAY;AACV,YAAM,IAAIF,SAAJ,CAAc,gDAAd,CAAN;AACD;;AACD,WAAO,CAACE,KAAD,CAAP;AACD;;AACD,QAAMmC,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMC,IAAX,IAAmB/C,KAAnB,EAA0B;AACxB,UAAMgD,KAAK,GAAGvD,GAAG,CAACmB,GAAJ,CAAQC,KAAR,CAAckC,IAAd,CAAd;;AACA,QAAI,CAACC,KAAL,EAAY;AACV,YAAM,IAAIvC,SAAJ,CAAc,gDAAd,CAAN;AACD;;AACDqC,IAAAA,MAAM,CAACG,IAAP,CAAYD,KAAZ;AACD;;AACD,SAAOF,MAAP;AACD;;AACD,MAAMI,SAAS,GAAG,IAAlB;AAEA3D,OAAO,CAACO,SAAR,GAAoBA,SAApB;AACAP,OAAO,CAACgC,YAAR,GAAuBA,YAAvB;AACAhC,OAAO,CAAC2D,SAAR,GAAoBA,SAApB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cid = require('multiformats/cid');\nvar encoder = require('./encoder.js');\nvar iteratorChannel = require('./iterator-channel.js');\nvar decoder = require('./decoder.js');\n\nclass CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    const cid$1 = cid.CID.asCID(block.cid);\n    if (!cid$1) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid: cid$1,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n  static create(roots) {\n    roots = toRoots(roots);\n    const {encoder, iterator} = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static createAppender() {\n    const {encoder, iterator} = encodeWriter();\n    encoder.setRoots = () => Promise.resolve();\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = decoder.bytesReader(bytes);\n    await decoder.readHeader(reader);\n    const newHeader = encoder.createHeader(roots);\n    if (reader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${ reader.pos } bytes, new header is ${ newHeader.length } bytes)`);\n    }\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n}\nclass CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n    this._iterating = true;\n    return this._iterator;\n  }\n}\nfunction encodeWriter() {\n  const iw = iteratorChannel.create();\n  const {writer, iterator} = iw;\n  const encoder$1 = encoder.createEncoder(writer);\n  return {\n    encoder: encoder$1,\n    iterator\n  };\n}\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    const cid$1 = cid.CID.asCID(roots);\n    if (!cid$1) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid$1];\n  }\n  const _roots = [];\n  for (const root of roots) {\n    const _root = cid.CID.asCID(root);\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    _roots.push(_root);\n  }\n  return _roots;\n}\nconst __browser = true;\n\nexports.CarWriter = CarWriter;\nexports.CarWriterOut = CarWriterOut;\nexports.__browser = __browser;\n"]},"metadata":{},"sourceType":"script"}