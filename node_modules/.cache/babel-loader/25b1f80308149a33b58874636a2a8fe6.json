{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar car = require('@ipld/car');\n\nvar block = require('multiformats/block');\n\nvar raw = require('multiformats/codecs/raw');\n\nvar dagCbor = require('@ipld/dag-cbor');\n\nvar pb = require('@ipld/dag-pb');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar raw__namespace = /*#__PURE__*/_interopNamespace(raw);\n\nvar dagCbor__namespace = /*#__PURE__*/_interopNamespace(dagCbor);\n\nvar pb__namespace = /*#__PURE__*/_interopNamespace(pb);\n\nclass TreewalkCarSplitter {\n  constructor(reader, targetSize, options = {}) {\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [pb__namespace, raw__namespace, dagCbor__namespace, ...(options.decoders || [])];\n  }\n\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1) throw new Error(`unexpected number of roots: ${roots.length}`);\n    let channel;\n\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out) yield val.out;\n    }\n\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n\n    channel.writer.close();\n    yield channel.out;\n  }\n\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock) throw new Error(`missing block for ${cid}`);\n    const {\n      bytes\n    } = rawBlock;\n\n    const decoder = this._decoders.find(d => d.code === cid.code);\n\n    if (!decoder) throw new Error(`missing decoder for ${cid.code}`);\n    return new block.Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n\n  async *_cars(cid, parents = [], channel = undefined) {\n    const block = await this._get(cid);\n    channel = channel || Object.assign(car.CarWriter.create(cid), {\n      size: 0\n    });\n\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {\n        out\n      } = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n\n    yield {\n      channel\n    };\n  }\n\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await car.CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await car.CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n\n}\n\nfunction newCar(parents) {\n  const ch = Object.assign(car.CarWriter.create(parents[0].cid), {\n    size: parents.reduce((size, b) => size + b.bytes.byteLength, 0)\n  });\n\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n\n  return ch;\n}\n\nexports.TreewalkCarSplitter = TreewalkCarSplitter;","map":{"version":3,"sources":["/Users/macdann/Desktop/ethccHack-NFT/Solar-NFT/node_modules/carbites/cjs/lib/treewalk/splitter.js"],"names":["Object","defineProperty","exports","value","car","require","block","raw","dagCbor","pb","_interopNamespace","e","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","raw__namespace","dagCbor__namespace","pb__namespace","TreewalkCarSplitter","constructor","reader","targetSize","options","Error","_reader","_targetSize","_decoders","decoders","cars","roots","getRoots","length","channel","val","_cars","out","writer","close","_get","cid","rawBlock","bytes","decoder","find","code","Block","decode","parents","undefined","assign","CarWriter","size","byteLength","newCar","concat","put","links","fromIterable","iterable","CarReader","fromBlob","blob","buffer","arrayBuffer","fromBytes","Uint8Array","ch","reduce","b"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar car = require('@ipld/car');\nvar block = require('multiformats/block');\nvar raw = require('multiformats/codecs/raw');\nvar dagCbor = require('@ipld/dag-cbor');\nvar pb = require('@ipld/dag-pb');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar raw__namespace = /*#__PURE__*/_interopNamespace(raw);\nvar dagCbor__namespace = /*#__PURE__*/_interopNamespace(dagCbor);\nvar pb__namespace = /*#__PURE__*/_interopNamespace(pb);\n\nclass TreewalkCarSplitter {\n  constructor(reader, targetSize, options = {}) {\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [\n      pb__namespace,\n      raw__namespace,\n      dagCbor__namespace,\n      ...options.decoders || []\n    ];\n  }\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1)\n      throw new Error(`unexpected number of roots: ${ roots.length }`);\n    let channel;\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out)\n        yield val.out;\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    channel.writer.close();\n    yield channel.out;\n  }\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock)\n      throw new Error(`missing block for ${ cid }`);\n    const {bytes} = rawBlock;\n    const decoder = this._decoders.find(d => d.code === cid.code);\n    if (!decoder)\n      throw new Error(`missing decoder for ${ cid.code }`);\n    return new block.Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n  async *_cars(cid, parents = [], channel = undefined) {\n    const block = await this._get(cid);\n    channel = channel || Object.assign(car.CarWriter.create(cid), { size: 0 });\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {out} = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    yield { channel };\n  }\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await car.CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await car.CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n}\nfunction newCar(parents) {\n  const ch = Object.assign(car.CarWriter.create(parents[0].cid), { size: parents.reduce((size, b) => size + b.bytes.byteLength, 0) });\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n  return ch;\n}\n\nexports.TreewalkCarSplitter = TreewalkCarSplitter;\n"]},"metadata":{},"sourceType":"script"}