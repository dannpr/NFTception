{"ast":null,"code":"import * as API from './lib/interface.js';\nimport { Blob, FormData } from './platform.js';\nimport { toGatewayURL, GATEWAY } from './gateway.js';\n/** @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions */\n\n/**\n * @template {API.TokenInput} T\n * @implements {API.Token<T>}\n */\n\nexport class Token {\n  /**\n   * @param {API.CIDString} ipnft\n   * @param {API.EncodedURL} url\n   * @param {API.Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft;\n    /** @readonly */\n\n    this.url = url;\n    /** @readonly */\n\n    this.data = data;\n    Object.defineProperties(this, {\n      ipnft: {\n        enumerable: true,\n        writable: false\n      },\n      url: {\n        enumerable: true,\n        writable: false\n      },\n      data: {\n        enumerable: false,\n        writable: false\n      }\n    });\n  }\n  /**\n   * @returns {API.Encoded<T, [[Blob, URL]]>}\n   */\n\n\n  embed() {\n    return Token.embed(this);\n  }\n  /**\n   * @template {API.TokenInput} T\n   * @param {{data: API.Encoded<T, [[Blob, URL]]>}} token\n   * @returns {API.Encoded<T, [[Blob, URL]]>}\n   */\n\n\n  static embed({\n    data\n  }) {\n    return embed(data, {\n      gateway: GATEWAY\n    });\n  }\n\n}\n/**\n * @template T\n * @param {API.Encoded<T, [[Blob, URL]]>} input\n * @param {EmbedOptions} options\n * @returns {API.Encoded<T, [[Blob, URL]]>}\n */\n\nexport const embed = (input, options) => mapWith(input, isURL, embedURL, options);\n/**\n * @template {API.TokenInput} T\n * @param {API.EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expcet EncodedURLs\n * @returns {Token<T>}\n */\n\nexport const decode = ({\n  ipnft,\n  url,\n  data\n}, paths) => new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths));\n/**\n * @param {any} value\n * @returns {value is URL}\n */\n\nconst isURL = value => value instanceof URL;\n/**\n * @template State\n * @param {State} state\n * @param {API.EncodedURL} url\n * @returns {[State, URL]}\n */\n\n\nconst decodeURL = (state, url) => [state, new URL(url)];\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\n\n\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)];\n/**\n * @param {any} value\n * @returns {value is object}\n */\n\n\nconst isObject = value => typeof value === 'object' && value != null;\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is API.EncodedURL}\n */\n\n\nconst isEncodedURL = (value, assetPaths, path) => typeof value === 'string' && assetPaths.has(path.join('.'));\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {API.TokenInput} T\n * @param {API.Encoded<T, [[Blob, Blob]]>} input\n * @returns {FormData}\n */\n\n\nexport const encode = input => {\n  const [form, meta] = mapValueWith(input, isBlob, encodeBlob, new FormData(), []);\n  form.set('meta', JSON.stringify(meta));\n  return form;\n};\n/**\n * @param {FormData} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[FormData, void]}\n */\n\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob);\n  return [data, undefined];\n};\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\n\n\nconst isBlob = value => value instanceof Blob;\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {API.Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {API.Encoded<T, [[I, O]]>}\n */\n\n\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, []);\n  return output;\n};\n/**\n * @template T, I, X, O, State\n * @param {API.Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\n\nconst mapValueWith = (input, p, f, state, path) => p(input, state, path) ? f(state, input, path) : Array.isArray(input) ? mapArrayWith(input, p, f, state, path) : isObject(input) ? mapObjectWith(input, p, f, state, path) : [\n  /** @type {any} */\nstate, input];\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {API.Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\n\n\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init;\n  const output = {};\n\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key]); // @ts-ignore\n\n    output[key] = out;\n    state = next;\n  }\n\n  return [state, output];\n};\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\n\n\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = [];\n  let state = init;\n\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index]);\n    output[index] = out;\n    state = next;\n  }\n\n  return [\n    /** @type {API.Encoded<T, [[I, O]]>} */\n  state, output];\n};","map":{"version":3,"sources":["/Users/macdann/Desktop/ethccHack-NFT/Solar-NFT/node_modules/nft.storage/src/token.js"],"names":["API","Blob","FormData","toGatewayURL","GATEWAY","Token","constructor","ipnft","url","data","Object","defineProperties","enumerable","writable","embed","gateway","input","options","mapWith","isURL","embedURL","decode","paths","isEncodedURL","decodeURL","value","URL","state","context","isObject","assetPaths","path","has","join","encode","form","meta","mapValueWith","isBlob","encodeBlob","set","JSON","stringify","blob","undefined","p","f","output","Array","isArray","mapArrayWith","mapObjectWith","init","key","entries","next","out","index","element"],"mappings":"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","sourcesContent":["import * as API from './lib/interface.js'\nimport { Blob, FormData } from './platform.js'\nimport { toGatewayURL, GATEWAY } from './gateway.js'\n\n/** @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions */\n\n/**\n * @template {API.TokenInput} T\n * @implements {API.Token<T>}\n */\nexport class Token {\n  /**\n   * @param {API.CIDString} ipnft\n   * @param {API.EncodedURL} url\n   * @param {API.Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {API.Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {API.TokenInput} T\n   * @param {{data: API.Encoded<T, [[Blob, URL]]>}} token\n   * @returns {API.Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: GATEWAY })\n  }\n}\n\n/**\n * @template T\n * @param {API.Encoded<T, [[Blob, URL]]>} input\n * @param {EmbedOptions} options\n * @returns {API.Encoded<T, [[Blob, URL]]>}\n */\nexport const embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {API.TokenInput} T\n * @param {API.EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expcet EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {API.EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is API.EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {API.TokenInput} T\n * @param {API.Encoded<T, [[Blob, Blob]]>} input\n * @returns {FormData}\n */\nexport const encode = (input) => {\n  const [form, meta] = mapValueWith(\n    input,\n    isBlob,\n    encodeBlob,\n    new FormData(),\n    []\n  )\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {FormData} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[FormData, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof Blob\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {API.Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {API.Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {API.Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {API.Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output = /** @type {API.Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [state, /** @type {API.Encoded<T, [[I, O]]>} */ (output)]\n}\n"]},"metadata":{},"sourceType":"module"}