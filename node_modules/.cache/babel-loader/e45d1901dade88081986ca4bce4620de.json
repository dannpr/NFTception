{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar decoder = require('./decoder.js');\n\nclass CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n\n  get version() {\n    return this._version;\n  }\n\n  async getRoots() {\n    return this._roots;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n\n    return decodeIndexerComplete(decoder.bytesReader(bytes));\n  }\n\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n\n    return decodeIndexerComplete(decoder.asyncIterableReader(asyncIterable));\n  }\n\n}\n\nasync function decodeIndexerComplete(reader) {\n  const decoder$1 = decoder.createDecoder(reader);\n  const {\n    version,\n    roots\n  } = await decoder$1.header();\n  return new CarIndexer(version, roots, decoder$1.blocksIndex());\n}\n\nexports.CarIndexer = CarIndexer;","map":{"version":3,"sources":["/Users/macdann/Desktop/ethccHack-NFT/Solar-NFT/node_modules/@ipld/car/cjs/lib/indexer.js"],"names":["Object","defineProperty","exports","value","decoder","require","CarIndexer","constructor","version","roots","iterator","_version","_roots","_iterator","getRoots","Symbol","asyncIterator","fromBytes","bytes","Uint8Array","TypeError","decodeIndexerComplete","bytesReader","fromIterable","asyncIterable","asyncIterableReader","reader","decoder$1","createDecoder","header","blocksIndex"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,cAAD,CAArB;;AAEA,MAAMC,UAAN,CAAiB;AACfC,EAAAA,WAAW,CAACC,OAAD,EAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AACpC,SAAKC,QAAL,GAAgBH,OAAhB;AACA,SAAKI,MAAL,GAAcH,KAAd;AACA,SAAKI,SAAL,GAAiBH,QAAjB;AACD;;AACU,MAAPF,OAAO,GAAG;AACZ,WAAO,KAAKG,QAAZ;AACD;;AACa,QAARG,QAAQ,GAAG;AACf,WAAO,KAAKF,MAAZ;AACD;;AACoB,GAApBG,MAAM,CAACC,aAAa,IAAI;AACvB,WAAO,KAAKH,SAAZ;AACD;;AACqB,eAATI,SAAS,CAACC,KAAD,EAAQ;AAC5B,QAAI,EAAEA,KAAK,YAAYC,UAAnB,CAAJ,EAAoC;AAClC,YAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AACD;;AACD,WAAOC,qBAAqB,CAACjB,OAAO,CAACkB,WAAR,CAAoBJ,KAApB,CAAD,CAA5B;AACD;;AACwB,eAAZK,YAAY,CAACC,aAAD,EAAgB;AACvC,QAAI,CAACA,aAAD,IAAkB,EAAE,OAAOA,aAAa,CAACT,MAAM,CAACC,aAAR,CAApB,KAA+C,UAAjD,CAAtB,EAAoF;AAClF,YAAM,IAAII,SAAJ,CAAc,2CAAd,CAAN;AACD;;AACD,WAAOC,qBAAqB,CAACjB,OAAO,CAACqB,mBAAR,CAA4BD,aAA5B,CAAD,CAA5B;AACD;;AA1Bc;;AA4BjB,eAAeH,qBAAf,CAAqCK,MAArC,EAA6C;AAC3C,QAAMC,SAAS,GAAGvB,OAAO,CAACwB,aAAR,CAAsBF,MAAtB,CAAlB;AACA,QAAM;AAAClB,IAAAA,OAAD;AAAUC,IAAAA;AAAV,MAAmB,MAAMkB,SAAS,CAACE,MAAV,EAA/B;AACA,SAAO,IAAIvB,UAAJ,CAAeE,OAAf,EAAwBC,KAAxB,EAA+BkB,SAAS,CAACG,WAAV,EAA/B,CAAP;AACD;;AAED5B,OAAO,CAACI,UAAR,GAAqBA,UAArB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar decoder = require('./decoder.js');\n\nclass CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n    return decodeIndexerComplete(decoder.bytesReader(bytes));\n  }\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n    return decodeIndexerComplete(decoder.asyncIterableReader(asyncIterable));\n  }\n}\nasync function decodeIndexerComplete(reader) {\n  const decoder$1 = decoder.createDecoder(reader);\n  const {version, roots} = await decoder$1.header();\n  return new CarIndexer(version, roots, decoder$1.blocksIndex());\n}\n\nexports.CarIndexer = CarIndexer;\n"]},"metadata":{},"sourceType":"script"}