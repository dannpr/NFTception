{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar varint = require('varint');\n\nvar cid = require('multiformats/cid');\n\nvar Digest = require('multiformats/hashes/digest');\n\nvar dagCbor = require('@ipld/dag-cbor');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);\n\nvar Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);\n\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\n\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint__default['default'].decode(bytes);\n  reader.seek(varint__default['default'].decode.bytes);\n  return i;\n}\n\nasync function readHeader(reader) {\n  const length = await readVarint(reader);\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = dagCbor.decode(header);\n\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${block.version}\"`);\n    }\n\n    throw new Error(`Invalid CAR version: ${block.version}`);\n  }\n\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  return block;\n}\n\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint__default['default'].decode(bytes);\n  const codeLength = varint__default['default'].decode.bytes;\n  const length = varint__default['default'].decode(bytes.subarray(varint__default['default'].decode.bytes));\n  const lengthLength = varint__default['default'].decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\n\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest__namespace.decode(bytes);\n    return cid.CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n\n  const version = await readVarint(reader);\n\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest__namespace.decode(bytes);\n  return cid.CID.create(version, codec, multihash);\n}\n\nasync function readBlockHead(reader) {\n  const start = reader.pos;\n  const length = (await readVarint(reader)) + (reader.pos - start);\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\n\nasync function readBlock(reader) {\n  const {\n    cid,\n    blockLength\n  } = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\n\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {\n    cid,\n    length,\n    blockLength\n  } = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\n\nfunction createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n\n    async *blocks() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n\n    async *blocksIndex() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n\n  };\n}\n\nfunction bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n\n      return bytes.subarray(pos, pos + length);\n    },\n\n    seek(length) {\n      pos += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\n\nfunction chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n\n    while (have < length) {\n      const chunk = await readChunk();\n\n      if (chunk.length === 0) {\n        break;\n      }\n\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n\n      have += chunk.length;\n    }\n\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n\n    offset = 0;\n  };\n\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n\n      return currentChunk.subarray(offset, offset + length);\n    },\n\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\n\nfunction asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n\n  async function readChunk() {\n    const next = await iterator.next();\n\n    if (next.done) {\n      return new Uint8Array(0);\n    }\n\n    return next.value;\n  }\n\n  return chunkReader(readChunk);\n}\n\nexports.asyncIterableReader = asyncIterableReader;\nexports.bytesReader = bytesReader;\nexports.chunkReader = chunkReader;\nexports.createDecoder = createDecoder;\nexports.readHeader = readHeader;","map":{"version":3,"sources":["/Users/macdann/Desktop/ethccHack-NFT/Solar-NFT/node_modules/@ipld/car/cjs/lib/decoder.js"],"names":["Object","defineProperty","exports","value","varint","require","cid","Digest","dagCbor","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","varint__default","Digest__namespace","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","reader","bytes","upTo","i","decode","seek","readHeader","length","header","exactly","block","Array","isArray","Error","version","roots","filter","p","readMultihash","codeLength","subarray","lengthLength","mhLength","multihash","readCid","first","CID","codec","readBlockHead","start","pos","blockLength","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","blocks","blocksIndex","bytesReader","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar varint = require('varint');\nvar cid = require('multiformats/cid');\nvar Digest = require('multiformats/hashes/digest');\nvar dagCbor = require('@ipld/dag-cbor');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);\nvar Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);\n\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint__default['default'].decode(bytes);\n  reader.seek(varint__default['default'].decode.bytes);\n  return i;\n}\nasync function readHeader(reader) {\n  const length = await readVarint(reader);\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = dagCbor.decode(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint__default['default'].decode(bytes);\n  const codeLength = varint__default['default'].decode.bytes;\n  const length = varint__default['default'].decode(bytes.subarray(varint__default['default'].decode.bytes));\n  const lengthLength = varint__default['default'].decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest__namespace.decode(bytes);\n    return cid.CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest__namespace.decode(bytes);\n  return cid.CID.create(version, codec, multihash);\n}\nasync function readBlockHead(reader) {\n  const start = reader.pos;\n  const length = await readVarint(reader) + (reader.pos - start);\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nfunction createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nfunction bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nfunction chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk.length === 0) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nfunction asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return new Uint8Array(0);\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}\n\nexports.asyncIterableReader = asyncIterableReader;\nexports.bytesReader = bytesReader;\nexports.chunkReader = chunkReader;\nexports.createDecoder = createDecoder;\nexports.readHeader = readHeader;\n"]},"metadata":{},"sourceType":"script"}