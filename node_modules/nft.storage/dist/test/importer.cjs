'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pb = require('ipld-dag-pb');
var multicodec = require('multicodec');
var Multihash = require('multihashing-async');
var IPLD = require('ipld');
var InMemory = require('ipld-in-memory');
var importer = require('ipfs-unixfs-importer');
var car = require('@ipld/car');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var pb__default = /*#__PURE__*/_interopDefaultLegacy(pb);
var multicodec__default = /*#__PURE__*/_interopDefaultLegacy(multicodec);
var Multihash__default = /*#__PURE__*/_interopDefaultLegacy(Multihash);
var IPLD__default = /*#__PURE__*/_interopDefaultLegacy(IPLD);
var InMemory__default = /*#__PURE__*/_interopDefaultLegacy(InMemory);
var importer__default = /*#__PURE__*/_interopDefaultLegacy(importer);

const DagPB = pb__default['default'].util;

/** @type {(T:typeof IPLD) => IPLD} */
const inMemory = InMemory__default['default'];
const { multihash } = Multihash__default['default'];

/**
 * @typedef {import('ipfs-unixfs-importer').BlockAPI} BlockAPI
 * @implements {BlockAPI}
 */
class Block {
  /**
   * @param {Object} [options]
   * @param {IPLD} [options.ipld]
   * @param {typeof multihash} [options.mh]
   */
  constructor({ ipld = inMemory(IPLD__default['default']), mh = multihash } = {}) {
    this.ipld = ipld;
    this.mh = mh;
  }
  /**
   * @param {Uint8Array} bytes
   * @param {{cid:import('ipfs-unixfs-importer').CID}} options
   */
  async put(bytes, { cid }) {
    const multihash = this.mh.decode(cid.multihash);
    const node = DagPB.deserialize(bytes);

    await this.ipld.put(node, multicodec__default['default'].DAG_PB, {
      cidVersion: cid.version,
      hashAlg: multihash.code,
    });

    return { cid, data: bytes }
  }
  /**
   * @param {import('ipfs-unixfs-importer').CID} cid
   * @param {any} options
   */
  async get(cid, options) {
    const node = await this.ipld.get(cid, options);

    if (node instanceof Uint8Array) {
      return { cid, data: node }
    } else {
      return { cid, data: DagPB.serialize(node) }
    }
  }
}

/**
 * @param {Uint8Array|string} content
 */
const importBlob = async (content) => {
  const results = importer__default['default']([{ content }], new Block(), { onlyHash: true });
  for await (const result of results) {
    return result
  }
  throw new Error(`Import failed`)
};

/**
 * @param {Uint8Array} content
 */
const importCar = async (content) => {
  const car$1 = await car.CarReader.fromBytes(content);
  const [cid] = await car$1.getRoots();
  if (!cid) {
    throw new Error(`Import failed`)
  }
  return { cid }
};

/**
 * @param {File[]} files
 */
const importDirectory = async (files) => {
  const entries = files.map((file) => ({
    // @ts-expect-error - webkitRelativePath is not known
    path: file.webkitRelativePath || file.name,
    // @ts-expect-error - file.stream() isn't typed as AsyncIterable.
    content: /** @type {AsyncIterable<Uint8Array>} */ (file.stream()),
  }));

  const results = importer__default['default'](entries, new Block(), {
    onlyHash: true,
    wrapWithDirectory: true,
  });

  let last = null;
  for await (const result of results) {
    last = result;
  }

  if (last != null) {
    return last
  } else {
    throw new Error(`Import failed`)
  }
};

exports.importBlob = importBlob;
exports.importCar = importCar;
exports.importDirectory = importDirectory;
//# sourceMappingURL=importer.cjs.map
