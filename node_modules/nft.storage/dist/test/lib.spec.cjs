'use strict';

var car = require('@ipld/car');
var assert = require('uvu/assert');
var nft_storage = require('nft.storage');
var multiformats = require('multiformats');
var pack = require('ipfs-car/pack');
var dagCbor = require('@ipld/dag-cbor');
var ipldGarbage = require('ipld-garbage');
var sha2 = require('multiformats/hashes/sha2');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var assert__namespace = /*#__PURE__*/_interopNamespace(assert);
var dagCbor__namespace = /*#__PURE__*/_interopNamespace(dagCbor);

const DWEB_LINK = 'dweb.link';

describe('client', () => {
  const { AUTH_TOKEN, SERVICE_ENDPOINT } = process.env;
  const token = AUTH_TOKEN || '';
  const endpoint = new URL(SERVICE_ENDPOINT || '');

  it('interface', () => {
    assert__namespace.equal(typeof nft_storage.NFTStorage, 'function');
    const client = new nft_storage.NFTStorage({ token: 'secret' });
    assert__namespace.ok(client instanceof nft_storage.NFTStorage);
    assert__namespace.equal(typeof client.storeBlob, 'function');
    assert__namespace.equal(typeof client.storeDirectory, 'function');
    assert__namespace.equal(typeof client.status, 'function');
    assert__namespace.equal(typeof client.delete, 'function');

    assert__namespace.equal(typeof nft_storage.NFTStorage.storeBlob, 'function');
    assert__namespace.equal(typeof nft_storage.NFTStorage.storeDirectory, 'function');
    assert__namespace.equal(typeof nft_storage.NFTStorage.status, 'function');
    assert__namespace.equal(typeof nft_storage.NFTStorage.delete, 'function');
  });
  describe('upload', () => {
    it('upload blob', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const cid = await client.storeBlob(new nft_storage.Blob(['hello world']));
      assert__namespace.equal(cid, 'Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD');
    });

    it('can upload twice', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const blob = new nft_storage.Blob(['upload twice']);
      const cid1 = await client.storeBlob(blob);
      const status1 = await client.status(cid1);

      const cid2 = await client.storeBlob(blob);
      const status2 = await client.status(cid2);

      assert__namespace.equal(cid1, cid2, 'cids match');
      assert__namespace.equal(status1.created, status2.created, 'dates match');
    });

    it('errors with invalid token', async () => {
      const client = new nft_storage.NFTStorage({ token: 'wrong', endpoint });
      const blob = new nft_storage.Blob(['upload twice']);

      try {
        await client.storeBlob(blob);
        assert__namespace.unreachable('sholud have failed');
      } catch (error) {
        assert__namespace.ok(error instanceof Error);
        assert__namespace.match(error, /Unauthorized/);
      }
    });

    it('errors without token', async () => {
      // @ts-ignore
      const client = new nft_storage.NFTStorage({ endpoint });
      try {
        await client.storeBlob(new nft_storage.Blob(['blobby']));
        assert__namespace.unreachable('should have thrown');
      } catch (err) {
        assert__namespace.is(err.message, 'missing token');
      }
    });

    it('errors without content', async () => {
      const client = new nft_storage.NFTStorage({ endpoint, token });
      try {
        await client.storeBlob(new nft_storage.Blob([]));
        assert__namespace.unreachable('should have thrown');
      } catch (err) {
        assert__namespace.match(err.message, /provide some content/);
      }
    });
  });

  describe('upload car', () => {
    it('upload CAR with a blob', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const { root, out } = await pack.pack({
        input: [new TextEncoder().encode('hello world')],
      });
      const expectedCid = root.toString();
      const carParts = [];
      for await (const part of out) {
        carParts.push(part);
      }
      const car = new nft_storage.Blob(carParts, { type: 'application/car' });
      const cid = await client.storeCar(car);
      assert__namespace.equal(cid, expectedCid);
    });

    it('upload CAR with a blob lacking blob.type', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const { root, out } = await pack.pack({
        input: [new TextEncoder().encode('hello world')],
      });
      const expectedCid = root.toString();
      const carParts = [];
      for await (const part of out) {
        carParts.push(part);
      }
      const car = new nft_storage.Blob(carParts);
      const cid = await client.storeCar(car);
      assert__namespace.equal(cid, expectedCid);
    });

    it('upload CAR with a CarReader', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const { root, out } = await pack.pack({
        input: [new TextEncoder().encode('hello world')],
      });
      const expectedCid = root.toString();

      const carReader = await car.CarReader.fromIterable(out);

      const cid = await client.storeCar(carReader);
      assert__namespace.equal(cid, expectedCid);
    });

    it('upload large CAR with a CarReader', async function () {
      this.timeout(130e3);
      let uploadedChunks = 0;

      const client = new nft_storage.NFTStorage({ token, endpoint });

      const targetSize = 1024 * 1024 * 120; // ~120MB CARs
      const carReader = await car.CarReader.fromIterable(
        await randomCar(targetSize)
      );

      const roots = await carReader.getRoots();
      const expectedCid = roots[0]?.toString();

      const cid = await client.storeCar(carReader, {
        onStoredChunk: () => {
          uploadedChunks++;
        },
      });
      assert__namespace.ok(uploadedChunks >= 12);
      assert__namespace.equal(cid, expectedCid);
    });
  });

  describe('upload dir', () => {
    it('upload a file', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const cid = await client.storeDirectory([
        new nft_storage.File(['hello world'], 'hello.txt'),
      ]);

      assert__namespace.equal(cid, 'QmNxvA5bwvPGgMXbmtyhxA1cKFdvQXnsGnZLCGor3AzYxJ');
    });

    it('upload multiple files', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const cid = await client.storeDirectory([
        new nft_storage.File(['hello world'], 'hello.txt'),
        new nft_storage.File(
          [JSON.stringify({ from: 'incognito' }, null, 2)],
          'metadata.json'
        ),
      ]);

      assert__namespace.equal(cid, 'QmQAE2tjfwYYmEFFEEnfr12CWikMqgwwtq5gqfyb62bJpw');
    });

    it('upload empty files', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        await client.storeDirectory([new nft_storage.File([], 'empty.txt')]);
        assert__namespace.unreachable('should fail if no content is provided');
      } catch (error) {
        assert__namespace.ok(error instanceof Error);
        assert__namespace.match(error, /provide some content/i);
      }
    });

    it('upload nothing', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        await client.storeDirectory([]);
        assert__namespace.unreachable('should fail if no content is provided');
      } catch (error) {
        assert__namespace.ok(error instanceof Error);
        assert__namespace.match(error, /provide some content/i);
      }
    });

    it('upload empty files', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        await client.storeDirectory([new nft_storage.File([], 'empty.txt')]);
        assert__namespace.unreachable('should fail if no content is provided');
      } catch (error) {
        assert__namespace.ok(error instanceof Error);
        assert__namespace.match(error, /provide some content/i);
      }
    });
    it('errors without token', async () => {
      // @ts-ignore
      const client = new nft_storage.NFTStorage({ endpoint });
      try {
        await client.storeDirectory([new nft_storage.File(['file'], 'file.txt')]);
        assert__namespace.unreachable('should have thrown');
      } catch (err) {
        assert__namespace.is(err.message, 'missing token');
      }
    });

    it('errors with invalid token', async () => {
      const client = new nft_storage.NFTStorage({ token: 'wrong', endpoint });

      try {
        await client.storeDirectory([new nft_storage.File(['wrong token'], 'foo.txt')]);
        assert__namespace.unreachable('sholud have failed');
      } catch (error) {
        assert__namespace.ok(error instanceof Error);
        assert__namespace.match(error, /Unauthorized/);
      }
    });
  });

  describe('store', async () => {
    it('requires name', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        // @ts-expect-error
        await client.store({});
        assert__namespace.unreachable('should have failed');
      } catch (error) {
        assert__namespace.ok(error instanceof TypeError);
        assert__namespace.match(
          error,
          /string property `name` identifying the asset is required/
        );
      }
    });

    it('requires description', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        // @ts-expect-error
        await client.store({ name: 'name' });
        assert__namespace.unreachable('sholud have failed');
      } catch (error) {
        assert__namespace.ok(error instanceof TypeError);
        assert__namespace.match(
          error,
          /string property `description` describing asset is required/
        );
      }
    });

    it('requires image', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        // @ts-expect-error
        await client.store({ name: 'name', description: 'stuff' });
        assert__namespace.unreachable('sholud have failed');
      } catch (error) {
        assert__namespace.ok(error instanceof TypeError);
        assert__namespace.match(error, /proprety `image` must be a Blob or File/);
      }
    });

    it('requires image mime type', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        await client.store({
          name: 'name',
          description: 'stuff',
          image: new nft_storage.Blob(['bla bla']),
        });
      } catch (error) {
        assert__namespace.ok(error instanceof TypeError);
        assert__namespace.match(error, /Blob or File object with `image\/\*` mime type/);
      }
    });

    it('expects decimal to be an int', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        await client.store({
          name: 'name',
          description: 'stuff',
          image: new nft_storage.Blob(['pretend image'], { type: 'image/png' }),
          // @ts-expect-error
          decimals: 'foo',
        });
      } catch (error) {
        assert__namespace.ok(error instanceof TypeError);
        assert__namespace.match(error, /proprety `decimals` must be an integer value/);
      }
    });

    it('errors without token', async () => {
      const client = new nft_storage.NFTStorage({ token: 'wrong', endpoint });

      try {
        await client.store({
          name: 'name',
          description: 'tada',
          image: new nft_storage.Blob([], { type: 'image/png' }),
        });
        assert__namespace.unreachable('sholud have failed');
      } catch (error) {
        assert__namespace.ok(error instanceof Error);
        assert__namespace.match(error, /Unauthorized/);
      }
    });

    it('uploads image', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const result = await client.store({
        name: 'name',
        description: 'stuff',
        image: new nft_storage.Blob(['fake image'], { type: 'image/png' }),
      });

      assert__namespace.ok(typeof result.url === 'string');
      assert__namespace.ok(new URL(result.url).protocol, 'ipfs:');

      assert__namespace.ok(typeof result.ipnft === 'string');
      assert__namespace.equal(multiformats.CID.parse(result.ipnft).version, 1);

      assert__namespace.equal(result.data.name, 'name');
      assert__namespace.equal(result.data.description, 'stuff');
      assert__namespace.ok(result.data.image instanceof URL);
      assert__namespace.ok(result.data.image.protocol, 'ipfs:');

      const embed = result.embed();
      assert__namespace.equal(embed.name, 'name');
      assert__namespace.equal(embed.description, 'stuff');
      assert__namespace.ok(embed.image instanceof URL);
      assert__namespace.ok(embed.image.protocol, 'https:');
    });

    it('store with properties', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const trick =
        'ipfs://bafyreiemweb3jxougg7vaovg7wyiohwqszmgwry5xwitw3heepucg6vyd4';
      const result = await client.store({
        name: 'name',
        description: 'stuff',
        image: new nft_storage.File(['fake image'], 'cat.png', { type: 'image/png' }),
        properties: {
          extra: 'meta',
          trick,
          src: [
            new nft_storage.File(['hello'], 'hello.txt', { type: 'text/plain' }),
            new nft_storage.Blob(['bye']),
          ],
        },
      });

      assert__namespace.ok(result instanceof nft_storage.Token);

      const cid = multiformats.CID.parse(result.ipnft);
      assert__namespace.equal(cid.version, 1);

      assert__namespace.ok(typeof result.url === 'string');
      assert__namespace.ok(result.url.startsWith('ipfs:'));

      assert__namespace.equal(result.data.name, 'name');
      assert__namespace.equal(result.data.description, 'stuff');
      assert__namespace.ok(result.data.image instanceof URL);
      assert__namespace.ok(result.data.image.protocol, 'ipfs:');

      assert__namespace.equal(result.data.properties.extra, 'meta');
      assert__namespace.equal(result.data.properties.trick, trick);
      assert__namespace.ok(Array.isArray(result.data.properties.src));
      assert__namespace.equal(result.data.properties.src.length, 2);

      const [h, b] = /** @type {[URL, URL]} */ (result.data.properties.src);
      assert__namespace.ok(h instanceof URL);
      assert__namespace.equal(h.protocol, 'ipfs:');

      assert__namespace.ok(b instanceof URL);
      assert__namespace.equal(b.protocol, 'ipfs:');

      const embed = result.embed();

      assert__namespace.equal(embed.name, 'name');
      assert__namespace.equal(embed.description, 'stuff');
      assert__namespace.ok(embed.image instanceof URL);
      assert__namespace.ok(embed.image.protocol, 'https:');
      assert__namespace.ok(embed.image.host, DWEB_LINK);

      assert__namespace.equal(embed.properties.extra, 'meta');
      assert__namespace.ok(Array.isArray(embed.properties.src));
      assert__namespace.equal(embed.properties.src.length, 2);

      const [h2, b2] = /** @type {[URL, URL]} */ (embed.properties.src);
      assert__namespace.ok(h2 instanceof URL);
      assert__namespace.equal(h2.protocol, 'https:');
      assert__namespace.equal(h2.host, DWEB_LINK);

      assert__namespace.ok(b2 instanceof URL);
      assert__namespace.equal(b2.protocol, 'https:');
      assert__namespace.equal(b2.host, DWEB_LINK);
    });

    it('store with OpenSea extensions', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const result = await client.store({
        name: 'name',
        description: 'stuff',
        image: new nft_storage.File(['fake image'], 'cat.png', { type: 'image/png' }),
        animation_url: new nft_storage.File(['fake vid'], 'vid.mp4', { type: 'video/mp4' }),
        background_color: 'ffffff',
        youtube_url: 'https://youtu.be/dQw4w9WgXcQ',
        attributes: [
          { trait_type: 'Aqua Power', display_type: 'boost_number' },
        ],
      });

      assert__namespace.ok(result instanceof nft_storage.Token);

      const cid = multiformats.CID.parse(result.ipnft);
      assert__namespace.equal(cid.version, 1);

      assert__namespace.ok(typeof result.url === 'string');
      assert__namespace.ok(result.url.startsWith('ipfs:'));

      assert__namespace.equal(result.data.name, 'name');
      assert__namespace.equal(result.data.description, 'stuff');
      assert__namespace.equal(result.data.background_color, 'ffffff');
      assert__namespace.equal(result.data.youtube_url, 'https://youtu.be/dQw4w9WgXcQ');
      assert__namespace.equal(result.data.attributes, [
        {
          trait_type: 'Aqua Power',
          display_type: 'boost_number',
        },
      ]);
      assert__namespace.ok(result.data.image instanceof URL);
      assert__namespace.ok(result.data.image.protocol, 'ipfs:');
      assert__namespace.ok(result.data.animation_url instanceof URL);
      assert__namespace.ok(result.data.animation_url.protocol, 'ipfs:');
    });
  });

  describe('status', () => {
    const client = new nft_storage.NFTStorage({ token, endpoint });

    /** @type {string[]} */
    let preloaded;
    beforeEach(async () => {
      preloaded = [
        // QmaCxv35MgHdAD2K9Tn8xrKVZJw7dauYi4V1GmkQRNYbvP
        await client.storeBlob(new nft_storage.Blob(['preload status'])),
        // QmTPFUEcZvqKBYqJM3itqkDiqJaApYzLJ1ht6iBD4d6M28
        // await client.storeBlob(new Blob(['missing']))
      ];
    });

    afterEach(async () => {
      await Promise.all(preloaded.map((cid) => client.delete(cid)));
    });

    it('found', async () => {
      const cid = 'QmaCxv35MgHdAD2K9Tn8xrKVZJw7dauYi4V1GmkQRNYbvP';
      const status = await client.status(cid);
      assert__namespace.equal(status.cid, cid);
    });

    it('not found', async () => {
      const cid = 'QmTPFUEcZvqKBYqJM3itqkDiqJaApYzLJ1ht6iBD4d6M28';
      try {
        await client.status(cid);
        assert__namespace.unreachable('Expected to fail');
      } catch (error) {
        assert__namespace.ok(error.message.match(/not found/));
      }
    });

    it('errors without token', async () => {
      // @ts-ignore
      const client = new nft_storage.NFTStorage({ endpoint });
      try {
        await client.status('QmaCxv35MgHdAD2K9Tn8xrKVZJw7dauYi4V1GmkQRNYbvP');
        assert__namespace.unreachable('should have thrown');
      } catch (err) {
        assert__namespace.is(err.message, 'missing token');
      }
    });

    it('decodes dates in deals', async () => {
      const cid = 'bafyreigdcnuc6w7stviim6a5m7uwqdw6p3z5zrqr22xt3num3ozra4ciqi';
      const pieceCid =
        'bagayreigdcnuc6w7stviim6a5m7uwqdw6p3z5zrqr22xt3num3ozra4ciqi';
      const status = await client.status(cid);
      assert__namespace.equal(status.cid, cid);
      assert__namespace.ok(status.created instanceof Date);
      assert__namespace.equal(status.deals, [
        {
          lastChanged: new Date('2021-03-18T11:46:50.000Z'),
          status: 'queued',
        },
        {
          batchRootCid: cid,
          lastChanged: new Date('2021-03-18T11:46:50.000Z'),
          miner: 't01234',
          network: 'nerpanet',
          pieceCid,
          status: 'proposing',
        },
        {
          batchRootCid: cid,
          lastChanged: new Date('2021-03-18T11:46:50.000Z'),
          miner: 'f05678',
          network: 'mainnet',
          pieceCid,
          status: 'accepted',
        },
        {
          batchRootCid: cid,
          lastChanged: new Date('2021-03-18T11:46:50.000Z'),
          miner: 'f09999',
          network: 'mainnet',
          pieceCid,
          status: 'failed',
          statusText: 'miner rejected my stuffz',
        },
        {
          batchRootCid: cid,
          chainDealID: 24526235,
          dealActivation: new Date('2021-03-18T11:46:50.000Z'),
          dealExpiration: new Date('2021-03-18T11:46:50.000Z'),
          lastChanged: new Date('2021-03-18T11:46:50.000Z'),
          miner: 'f34523',
          network: 'mainnet',
          pieceCid,
          status: 'active',
        },
      ]);
    });
  });

  describe('delete', () => {
    it('ok to delete unknown', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const cid = 'Qmf412jQZiuVUtdgnB36FXFX7xg5V6KEbSJ4dpQuhkLyfD';
      const result = await client.delete(cid);
      assert__namespace.equal(result, undefined);
    });

    it('gone after delete', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      const cid = await client.storeBlob(new nft_storage.Blob(['to be deleted']));
      await client.status(cid);
      await client.delete(cid);
      try {
        await client.status(cid);
        assert__namespace.unreachable('should be gone');
      } catch (error) {
        assert__namespace.ok(error.message.includes('not found'));
      }
    });

    it('invalid cid errors', async () => {
      const client = new nft_storage.NFTStorage({ token, endpoint });
      try {
        await client.delete('foo');
        assert__namespace.unreachable('invalid cid');
      } catch (error) {
        assert__namespace.ok(error instanceof Error);
        assert__namespace.match(error, /parse non base32/);
      }
    });

    it('errors without token', async () => {
      // @ts-ignore
      const client = new nft_storage.NFTStorage({ endpoint });
      try {
        const cid = await nft_storage.NFTStorage.storeBlob(
          { token, endpoint },
          new nft_storage.Blob(['deleteme'])
        );
        await client.delete(cid);
        assert__namespace.unreachable('should have thrown');
      } catch (err) {
        assert__namespace.is(err.message, 'missing token');
      }
    });
  });

  describe('check', () => {
    const client = new nft_storage.NFTStorage({ token, endpoint });

    /** @type {string[]} */
    let preloaded;
    beforeEach(async () => {
      preloaded = [
        // QmVRC63ZHwHQBC4pkqbiQjPjdHVKueafTpwmkNHhnVfwLQ
        await client.storeBlob(new nft_storage.Blob(['preload check'])),
        // QmTPFUEcZvqKBYqJM3itqkDiqJaApYzLJ1ht6iBD4d6M28
        // await client.storeBlob(new Blob(['missing']))
      ];
    });

    afterEach(async () => {
      await Promise.all(preloaded.map((cid) => client.delete(cid)));
    });

    it('found', async () => {
      const cid = 'QmVRC63ZHwHQBC4pkqbiQjPjdHVKueafTpwmkNHhnVfwLQ';
      const status = await client.check(cid);
      assert__namespace.equal(status.cid, cid);
    });

    it('not found', async () => {
      const cid = 'QmTPFUEcZvqKBYqJM3itqkDiqJaApYzLJ1ht6iBD4d6M28';
      try {
        await client.check(cid);
        assert__namespace.unreachable('Expected to fail');
      } catch (error) {
        assert__namespace.ok(error.message.match(/not found/));
      }
    });
  });
});

const MAX_BLOCK_SIZE = 1024 * 1024 * 4;

function randomBlockSize() {
  const max = MAX_BLOCK_SIZE;
  const min = max / 2;
  return Math.random() * (max - min) + min
}

/**
 * @param {number} targetSize
 * @returns {Promise<AsyncIterable<Uint8Array>>}
 */
async function randomCar(targetSize) {
  const blocks = [];
  let size = 0;
  const seen = new Set();
  while (size < targetSize) {
    const bytes = dagCbor__namespace.encode(
      ipldGarbage.garbage(randomBlockSize(), { weights: { CID: 0 } })
    );
    const hash = await sha2.sha256.digest(bytes);
    const cid = multiformats.CID.create(1, dagCbor__namespace.code, hash);
    if (seen.has(cid.toString())) continue
    seen.add(cid.toString());
    blocks.push({ cid, bytes });
    size += bytes.length;
  }
  const rootBytes = dagCbor__namespace.encode(blocks.map((b) => b.cid));
  const rootHash = await sha2.sha256.digest(rootBytes);
  const rootCid = multiformats.CID.create(1, dagCbor__namespace.code, rootHash);
  const { writer, out } = car.CarWriter.create([rootCid]);
  writer.put({ cid: rootCid, bytes: rootBytes });
  blocks.forEach((b) => writer.put(b));
  writer.close();
  return out
}
//# sourceMappingURL=lib.spec.cjs.map
